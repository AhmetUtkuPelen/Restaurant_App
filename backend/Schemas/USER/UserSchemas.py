from pydantic import BaseModel, ConfigDict, EmailStr, field_validator, Field
from typing import Optional, List
from datetime import datetime
import re

from Utils.Enums.Enums import UserRole as Role

# Pydantic v2 config for ORM -> dict conversion and Enums + Decimal handling
model_conf = ConfigDict(from_attributes=True, orm_mode=True)

# -------------------
# Token Schemas
# -------------------
class Token(BaseModel):
    model_config = model_conf
    access_token: str
    token_type: str = "bearer"


class TokenData(BaseModel):
    model_config = model_conf
    username: Optional[str] = None

# -------------------
# Base User Schemas
# -------------------
class UserBase(BaseModel):
    model_config = model_conf
    email: EmailStr
    username: str
    image_url: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    role: Optional[Role] = Role.USER

    @field_validator("username")
    def username_alphanumeric(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("username cannot be empty")
        v2 = v.strip()
        if not re.match(r"^[A-Za-z0-9._-]{3,20}$", v2):
            raise ValueError("Username must be 3-20 chars and contain only letters, digits, ., _, -")
        return v2
    
    @field_validator("email", mode="before")
    def email_lower(cls, v: str) -> str:
        return v.lower() if isinstance(v, str) else v

    @field_validator('email')
    def email_format(cls, v):
        pattern = r'^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'
        if not re.match(pattern, v):
            raise ValueError('Invalid email format!')
        return v
    
    @field_validator('phone')
    def phone_format(cls, v):
        if not v:
            return None
        # Support international format: +90XXXXXXXXXX or 10 digits
        pattern = r'^(\+90\d{10}|\d{10})$'
        if not re.match(pattern, v):
            raise ValueError('Invalid phone number format! Use 10 digits or +90XXXXXXXXXX')
        return v
    
    @field_validator('address')
    def address_format(cls, v):
        if not v:
            return None
        if len(v) < 5:
            raise ValueError('Address must be at least 5 characters long!')
        return v

# -------------------
# Schemas for Specific Actions
# -------------------
class UserLogin(BaseModel):
    """
    Schema for user login.
    """
    model_config = model_conf
    username: str
    password: str

class UserRegister(UserBase):
    """
    Schema for user registration.
    """
    model_config = model_conf
    username: str
    email: EmailStr
    password: str
    image_url : Optional[str] = None

class UserUpdate(BaseModel):
    """
    Schema for User to update user information of himself.
    """
    model_config = model_conf
    # allow partial updates (all optional)
    username: Optional[str] = None
    email: Optional[EmailStr] = None
    image_url: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    password: Optional[str] = None  # Allow password update


class AdminCreateUser(BaseModel):
    """
    Schema for admin to create a new user.
    """
    model_config = model_conf
    username: str
    email: EmailStr
    password: str
    role: Optional[Role] = Role.USER
    image_url: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    is_active: Optional[bool] = True
    
    @field_validator("username")
    def username_alphanumeric(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("username cannot be empty")
        v2 = v.strip()
        if not re.match(r"^[A-Za-z0-9._-]{3,20}$", v2):
            raise ValueError("Username must be 3-20 chars and contain only letters, digits, ., _, -")
        return v2

class AdminUpdateUser(BaseModel):
    """
    Schema for admin to update user information.
    """
    model_config = model_conf
    username: Optional[str] = None
    email: Optional[EmailStr] = None
    role: Optional[Role] = None
    image_url: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    is_active: Optional[bool] = None
    password: Optional[str] = None  # Admin can reset password

class AdminHardDeleteUser(BaseModel):
    """
    Schema for admin to delete a user.
    """
    model_config = model_conf
    id: int

class AdminSoftDeleteUser(BaseModel):
    """
    Schema for admin to soft delete a user.
    """
    model_config = model_conf
    id: int
    is_active: bool = False

# -------------------
# Schemas for Database and API Responses
# -------------------
class UserInDbBase(UserBase):
    """
    Base schema for user data as it is in the database.
    Includes fields that are generated by the server.
    """
    model_config = model_conf
    id: int
    is_active: bool = True
    created_at: datetime
    updated_at: Optional[datetime] = None
    deleted_at: Optional[datetime] = None
    image_url: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    role: Role
    # Relations (by id or shallow representations)
    favourite_products: List[int] = Field(default_factory=list)
    orders: List[int] = Field(default_factory=list)
    comments: List[int] = Field(default_factory=list)
    cart: Optional[dict] = None
    reservations: List[int] = Field(default_factory=list)
    payments: List[int] = Field(default_factory=list)

class User(UserInDbBase):
    """
    Schema for representing a user in API responses.
    This is what the outside world will see. It does NOT include the password.
    """
    model_config = model_conf
    # public-facing user schema: includes related ids and non-sensitive info
    pass

class UserInDb(UserInDbBase):
    """
    Schema for user data including the hashed password.
    This should only be used internally, never sent in an API response.
    """
    model_config = model_conf
    # matches the model's `hashed_password` column
    hashed_password: str


### User Profile Schemas
class UserProfileRead(BaseModel):
    """Read-only profile view for users (what they see when fetching their profile)."""
    model_config = model_conf
    id: int
    username: str
    email: EmailStr
    image_url: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    role: str  # Role as string value
    is_active: bool
    created_at: datetime
    favourite_products: List[int] = Field(default_factory=list)
    orders: List[int] = Field(default_factory=list)
    comments: List[int] = Field(default_factory=list)
    cart: Optional[dict] = None
    reservations: List[int] = Field(default_factory=list)
    payments: List[int] = Field(default_factory=list)


class UserProfileUpdate(BaseModel):
    """Payload for updating the profile. Password is optional and will be hashed."""
    model_config = model_conf
    username: Optional[str] = None
    email: Optional[EmailStr] = None
    password: Optional[str] = None
    image_url: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None